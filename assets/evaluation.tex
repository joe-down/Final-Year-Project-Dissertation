Overall WebMGA works well for performing its required visualisation tasks, with superior visual results compared to QMGA. Sufficiently high framerates are achieved to allow for responsive user interaction with reasonably sized configurations.

There are some substantial shortcomings in the implementation which are worth addressing. One of the key problems encountered during development was a lack of comments within the existing code, making it very difficult to determine what many sections were intended to do. Some additional comments were added, however it would still be difficult for a new developer to easily pick up the project. A particularly prevalent problem in the code is that many functions take in a tuple of values or a json format as an input, rather than being separate function parameters. These formats were rarely if ever documented, significantly obfuscating how these methods operate or should be called, and required manual debug inspection to determine their required format.

There were many minor bugs throughout the program which resulted in a desynchronisation between the state selected in the UI and the render shown. While I was able to patch many of these relatively simply by fixing minor logic errors in the code, it is difficult to determine if any of these still exist since there are a large number of setting combinations possible and some of these bugs existed only with very specific combinations. These issues seem to result from the Model-Controller-View structure WebMGA was designed around not being entirely successfully implemented, with the controller failing in some cases to update the Model (graphics render) on all View (GUI setting) updates. The state of certain configuration settings is often stored separately in all three of these parts of the program, resulting in two possible stages for desync to occur between View and Controller, and Controller and View. State should have been consistently stored and referenced only from the Controller.
